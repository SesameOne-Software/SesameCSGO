#include "exploits.hpp"
#include "ragebot.hpp"

#include "../menu/options.hpp"

#include "../hooks/create_move.hpp"
#include "prediction.hpp"

#undef min
#undef max

float next_shot_time = 0.0f;
int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int shifted_to_tickbase = 0;
int last_shifted_amount_ticks = 0;
bool should_teleport = false;

bool exploits::can_shoot ( ) {
	if ( !g::local || !g::local->weapon ( ) || !g::local->weapon ( )->ammo ( ) )
		return false;

	const auto weapon = g::local->weapon ( );
	const auto server_time = cs::ticks2time ( g::local->tick_base ( ) );

	if ( weapon->item_definition_index ( ) == weapons_t::revolver )
		return g::can_fire_revolver;

	return server_time >= g::local->next_attack ( ) && server_time >= weapon->next_primary_attack ( );
}

int exploits::shifted_tickbase ( ) {
	return shifted_to_tickbase;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	return !shifted_counter;
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	if ( should_teleport ) {
		if ( recharge_delay_counter ) {
			recharge_delay_counter--;
			return false;
		}

		if ( shifted_counter ) {
			ucmd->m_tickcount += static_cast<int>( cs::time2ticks ( 1.0f ) * 3.125f );
			shifted_counter--;
			has_shifted = false;
			return true;
		}

		return false;
	}
	else {
		recharge_delay_counter = 0;

		if ( shifted_counter ) {
			shifted_counter--;
			has_shifted = false;
			return false;
		}

		return false;
	}
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 );
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::extend_recharge_delay ( int recharge_delay ) {
	if ( should_teleport && recharge_delay_counter > 0 )
		recharge_delay_counter = recharge_delay;
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;
	}
}

void exploits::update_incoming_sequences ( int stage ) {
	if ( stage != 2 )
		return;

	if ( !cs::i::client_state || !cs::i::client_state->net_channel( ) )
		return;

	auto nc = cs::i::client_state->net_channel ( );
	
	if ( nc->in_seq_nr > last_incoming_seq_num ) {
		last_incoming_seq_num = nc->in_seq_nr;
		incoming_seqs.push_front ( { nc->in_reliable_state, nc->out_reliable_state, nc->in_seq_nr, cs::i::globals->m_realtime } );
	}

	if ( incoming_seqs.size ( ) > 2048 )
		incoming_seqs.pop_back ( );
}

void exploits::adjust_player_time_base ( player_t* player, int simulation_ticks ) {
	if ( simulation_ticks < 0 )
		return;

	static auto cl_predict = cs::i::cvar->find ( _ ( "cl_predict" ) );									/* default to 1 */
	static auto sv_clockcorrection_msecs = cs::i::cvar->find ( _ ( "sv_clockcorrection_msecs" ) );		/* default to 30 */
	static auto sv_playerperfhistorycount = cs::i::cvar->find ( _ ( "sv_playerperfhistorycount" ) );	/* default to 20 */

	/* adjust tickbase below */
	const auto server_tick = player->tick_base ( );

	/* set final simulation time */
	if ( !cl_predict->get_bool( ) || cs::i::globals->m_max_clients == 1 ) {
		player->tick_base ( ) = server_tick - simulation_ticks /*+ cs::i::globals->sim_ticks_this_frame*/;
	}
	/* multiplayer */
	else {
		/* clock correction time */
		const auto correction_seconds = std::clamp ( sv_clockcorrection_msecs->get_float( ) / 1000.0f, 0.0f, 1.0f );
		const auto correction_ticks = cs::time2ticks ( correction_seconds );

		/* find ideal tick */
		const auto ideal_final_tick = server_tick + correction_ticks;
		const auto estimated_final_tick = player->tick_base ( ) + simulation_ticks;

		/* correct if client goes ahead of this */
		const auto too_fast_limit = ideal_final_tick + correction_ticks;

		/* correct if client falls behind this */
		const auto too_slow_limit = ideal_final_tick - correction_ticks;

		/* see if we are too fast */
		if ( estimated_final_tick > too_fast_limit || estimated_final_tick < too_slow_limit ) {
			const auto corrected_tick = ideal_final_tick - simulation_ticks /*+ cs::i::globals->sim_ticks_this_frame*/;

			player->tick_base ( ) = corrected_tick;
		}
	}
}

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	should_teleport = teleport;

	auto net_chan = cs::i::client_state->net_channel ( );

	if ( !net_chan )
		return;

	last_shifted_amount_ticks = num;
	shifted_to_tickbase = g::local->tick_base ( );

	static auto& enabled = options::vars [ _ ( "ragebot.autopeek" ) ].val.b;
	static auto& autopeek_key = options::vars [ _ ( "ragebot.autopeek_key" ) ].val.i;
	static auto& autopeek_key_mode = options::vars [ _ ( "ragebot.autopeek_key_mode" ) ].val.i;

	const auto autopeek_active = enabled && utils::keybind_active ( autopeek_key, autopeek_key_mode );

	vec3_t backup_angles;
	cs::i::engine->get_viewangles ( backup_angles );
	const auto backup_cmd = *ucmd;

	const auto backup_move_magnitude = sqrt ( ucmd->m_fmove * ucmd->m_fmove + ucmd->m_smove * ucmd->m_smove );
	const auto backup_vel_magnitude = features::prediction::vel.length_2d ( );

	g::send_packet = false;

	for ( auto i = 0; i < num; i++ ) {
		auto next_verified_cmd = cs::i::input->get_verified_cmd ( ucmd->m_cmdnum + 1 );
		auto next_cmd = cs::i::input->get_cmd ( ucmd->m_cmdnum + 1 );

		*next_cmd = *ucmd;

		next_cmd->m_angs = next_cmd->m_aimdir = backup_angles;
		next_cmd->m_angs = backup_angles;
		next_cmd->m_fmove = backup_cmd.m_fmove;
		next_cmd->m_smove = backup_cmd.m_smove;
		next_cmd->m_umove = backup_cmd.m_umove;

		next_cmd->m_cmdnum++;
		next_cmd->m_tickcount += teleport ? 1 : static_cast< int >( cs::time2ticks ( 1.0f ) * 3.125f );

		next_cmd->m_buttons |= buttons_t::bullrush;
		next_cmd->m_buttons &= ~( buttons_t::attack | buttons_t::attack2 );

		next_cmd->m_hasbeenpredicted = true;

		cs::i::client_state->choked ( )++;
		
		net_chan->choked_packets++;
		net_chan->out_seq_nr++;

		//auto correction_ticks = cs::time2ticks ( std::clamp ( g::cvars::sv_clockcorrection_msecs->get_float ( ) / 1000.f, 0.0f, 1.0f ) );
		//correction_ticks -= cs::i::client_state->choked ( );
		//correction_ticks += g::server_tick;
		//correction_ticks += cs::time2ticks ( cs::i::engine->get_net_channel_info ( )->get_latency ( 0 ) + cs::i::engine->get_net_channel_info ( )->get_latency ( 1 ) );

		tickshift [ ( cs::i::client_state->last_outgoing_cmd ( ) + 1 ) % tickshift.size ( ) ] = { cs::i::client_state->last_outgoing_cmd ( ) + 1, i + 1 };

		if ( features::prediction::vel_modifier < 1.0f )
			features::prediction::vel_modifier = std::clamp ( features::prediction::vel_modifier + cs::ticks2time ( 1 ) * 0.4f, 0.0f, 1.0f );

		in_exploit = true;
		hooks::create_move ( nullptr, nullptr, 0.0f, next_cmd );
		in_exploit = false;

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		/* set from cmd */
		ucmd = next_cmd;
	}

	shifted_to_command = ucmd->m_cmdnum;

	*reinterpret_cast< bool* > ( reinterpret_cast< uintptr_t >( cs::i::pred ) + 0x24 ) = true;
	*reinterpret_cast< int* > ( reinterpret_cast< uintptr_t >( cs::i::pred ) + 0x1C ) = 0;

	g::send_packet = true;
}

void exploits::run ( ucmd_t* ucmd ) {
	if ( !shifted_counter && queued_shift_amount ) {
		pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

		next_shot_time = ( ( g::local && g::local->weapon ( ) && g::local->weapon ( )->data ( ) ) ? ( g::local->weapon ( )->next_primary_attack ( ) + g::local->weapon ( )->data ( )->m_fire_rate ) : 0.0f );

		shifted_counter = queued_shift_amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 ) + 1;
		queued_shift_amount = 0;
		has_shifted = true;
	}
}