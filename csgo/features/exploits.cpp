#include "exploits.hpp"
#include "ragebot.hpp"

#include "../hooks/create_move.hpp"

#undef min
#undef max

float next_shot_time = 0.0f;
int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int last_shifted_amount_ticks = 0;
int shifted_tickbase_ticks = 0;
bool should_teleport = false;

bool exploits::can_shoot ( ) {
	if ( !g::local || !g::local->weapon ( ) || !g::local->weapon ( )->ammo ( ) )
		return false;

	const auto curtime = cs::ticks2time ( g::local->tick_base ( ) );

	if ( g::local->weapon ( )->item_definition_index ( ) == weapons_t::revolver && !( g::can_fire_revolver || g::local->tick_base ( ) > g::cock_ticks ) )
		return false;

	return curtime >= g::local->next_attack ( ) && ( curtime >= g::local->weapon ( )->next_primary_attack ( ) || ( (next_shot_time > 0.0f && has_shifted ) ? ( curtime > next_shot_time) : false ));
}

int exploits::shifted_tickbase ( ) {
	return shifted_tickbase_ticks;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	return !shifted_counter;
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
		if ( should_teleport ) {
			if ( recharge_delay_counter ) {
				recharge_delay_counter--;
				return false;
			}

			if ( shifted_counter ) {
				ucmd->m_tickcount = std::numeric_limits<int>::max ( );
				//ucmd->m_tickcount += 666;
				shifted_counter--;
				has_shifted = false;
				return true;
			}

			return false;
		}
		else {
			recharge_delay_counter = 0;

			if ( shifted_counter ) {
				shifted_counter--;
				has_shifted = false;
				return false;
			}

			return false;
		}
	VM_TIGER_BLACK_END
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount + (( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt )) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 );
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;
		shifted_tickbase_ticks = amount;
	}
}

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	VM_TIGER_BLACK_START
		should_teleport = teleport;

	auto net_chan = cs::i::client_state->net_channel ( );

	if ( !net_chan )
			return;

	last_shifted_amount_ticks = num;
	
	for ( auto i = 0; i < num; i++ ) {
		auto next_verified_cmd = cs::i::input->get_verified_cmd ( ucmd->m_cmdnum + 1 );
		auto next_cmd = cs::i::input->get_cmd ( ucmd->m_cmdnum + 1 );

		/* create next command */
		*next_cmd = *ucmd;

		next_cmd->m_cmdnum++;
		next_cmd->m_hasbeenpredicted = false;
		//next_cmd->m_buttons &= ~buttons_t::attack;
		//next_cmd->m_buttons &= ~buttons_t::attack2;
		//next_cmd->m_buttons &= ~buttons_t::walk;

		if ( !teleport )
			next_cmd->m_tickcount += 2000;
			//next_cmd->m_tickcount = std::numeric_limits<int>::max ( );

		/* set clientstate choke + net channel choke, and increment seq. num. */
		cs::i::client_state->choked ( )++;

		net_chan->m_choked_packets++;
		net_chan->m_out_sequence_nr++;

		if ( g::local )
			g::local->tick_base ( )++;

		in_exploit = true;
		hooks::create_move ( nullptr, nullptr, 0.0f, next_cmd );
		in_exploit = false;

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		/* set from cmd */
		ucmd = next_cmd;

		shifted_to_command = next_cmd->m_cmdnum;
	}

	cs::i::pred->m_previous_start_frame = -1;
	cs::i::pred->m_commands_predicted = 0;
	VM_TIGER_BLACK_END
}

void exploits::run ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
	if ( !shifted_counter && queued_shift_amount ) {
		pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

		next_shot_time = ( ( g::local && g::local->weapon ( ) && g::local->weapon ( )->data ( ) ) ? ( g::local->weapon ( )->next_primary_attack ( ) + g::local->weapon ( )->data ( )->m_fire_rate ) : 0.0f );

		shifted_counter = queued_shift_amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 ) + 1;
		queued_shift_amount = 0;
		has_shifted = true;
	}

	VM_TIGER_BLACK_END
}