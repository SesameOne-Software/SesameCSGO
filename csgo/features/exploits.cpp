#include "exploits.hpp"
#include "ragebot.hpp"

int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int last_shifted_amount_ticks = 0;
int shifted_tickbase_ticks = 0;

int exploits::shifted_tickbase ( ) {
	return shifted_tickbase_ticks;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	return !shifted_counter;
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	if ( recharge_delay_counter ) {
		recharge_delay_counter--;
		return false;
	}

	if ( shifted_counter ) {
		ucmd->m_tickcount += 1000;
		shifted_counter--;
		has_shifted = false;
		return true;
	}

	return false;
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount;
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;

		shifted_tickbase_ticks = ( g::local ? g::local->tick_base ( ) : 0 ) + amount;
	}
}

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	auto net_chan = cs::i::client_state->net_channel ( );

	if ( !net_chan )
		return;

	last_shifted_amount_ticks = num;
	
	for ( auto i = 0; i < num; i++ ) {
		auto next_verified_cmd = cs::i::input->get_verified_cmd ( ucmd->m_cmdnum + 1 );
		auto next_cmd = cs::i::input->get_cmd ( ucmd->m_cmdnum + 1 );

		/* create next command */
		*next_cmd = *ucmd;

		next_cmd->m_cmdnum++;
		next_cmd->m_hasbeenpredicted = false;
		next_cmd->m_buttons &= ~buttons_t::attack;
		next_cmd->m_buttons &= ~buttons_t::attack2;
		next_cmd->m_buttons &= ~buttons_t::walk;

		shifted_to_command = next_cmd->m_cmdnum;

		if ( !teleport )
			next_cmd->m_tickcount += 1000;

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		/* set from cmd */
		ucmd = next_cmd;

		/* set clientstate shit */
		cs::i::client_state->choked ( )++;

		net_chan->m_choked_packets++;
		net_chan->m_out_sequence_nr++;
	}

	cs::i::pred->m_previous_start_frame = -1;
	cs::i::pred->m_commands_predicted = 0;
}

void exploits::run ( ucmd_t* ucmd ) {
	if ( !shifted_counter && queued_shift_amount ) {
		pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

		shifted_counter = queued_shift_amount;
		queued_shift_amount = 0;

		has_shifted = true;
	}
}