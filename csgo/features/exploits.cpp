#include "exploits.hpp"
#include "ragebot.hpp"

#undef min
#undef max

int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int last_shifted_amount_ticks = 0;
int shifted_tickbase_ticks = 0;
bool should_teleport = false;

int exploits::shifted_tickbase ( ) {
	return shifted_tickbase_ticks;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	return !shifted_counter;
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
		if ( should_teleport ) {
			if ( recharge_delay_counter ) {
				recharge_delay_counter--;
				return false;
			}

			if ( shifted_counter ) {
				ucmd->m_tickcount = std::numeric_limits<int>::max ( );
				shifted_counter--;
				has_shifted = false;
				return true;
			}

			return false;
		}
		else {
			recharge_delay_counter = 0;

			if ( shifted_counter ) {
				shifted_counter--;
				has_shifted = false;
				return true;
			}

			return false;
		}
	VM_TIGER_BLACK_END
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount;
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;

		shifted_tickbase_ticks = amount;
	}
}

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	VM_TIGER_BLACK_START
		should_teleport = teleport;

	auto net_chan = cs::i::client_state->net_channel ( );

	if ( !net_chan )
			return;

	last_shifted_amount_ticks = num;
	
	for ( auto i = 0; i < num; i++ ) {
		auto next_verified_cmd = cs::i::input->get_verified_cmd ( ucmd->m_cmdnum + 1 );
		auto next_cmd = cs::i::input->get_cmd ( ucmd->m_cmdnum + 1 );

		/* create next command */
		*next_cmd = *ucmd;

		next_cmd->m_cmdnum++;
		next_cmd->m_hasbeenpredicted = false;
		next_cmd->m_buttons &= ~buttons_t::attack;
		next_cmd->m_buttons &= ~buttons_t::attack2;
		next_cmd->m_buttons &= ~buttons_t::walk;

		shifted_to_command = next_cmd->m_cmdnum;

		if ( !teleport )
			next_cmd->m_tickcount = std::numeric_limits<int>::max ( );

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		/* set from cmd */
		ucmd = next_cmd;

		/* set clientstate shit */
		cs::i::client_state->choked ( )++;

		net_chan->m_choked_packets++;
		net_chan->m_out_sequence_nr++;
	}

	cs::i::pred->m_previous_start_frame = -1;
	cs::i::pred->m_commands_predicted = 0;
	VM_TIGER_BLACK_END
}

void exploits::run ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
	if ( !shifted_counter && queued_shift_amount ) {
		pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

		shifted_counter = queued_shift_amount;

		queued_shift_amount = 0;

		has_shifted = true;
	}
	VM_TIGER_BLACK_END
}