#include "exploits.hpp"
#include "ragebot.hpp"

#include "../menu/options.hpp"

#include "../hooks/create_move.hpp"

#undef min
#undef max

float next_shot_time = 0.0f;
int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int shifted_to_tickbase = 0;
int last_shifted_amount_ticks = 0;
bool should_teleport = false;

bool exploits::can_shoot ( ) {
	if ( !g::local || !g::local->weapon ( ) || !g::local->weapon ( )->ammo ( ) )
		return false;

	const auto weapon = g::local->weapon ( );
	const auto server_time = cs::ticks2time ( g::local->tick_base ( ) );

	if ( weapon->item_definition_index ( ) == weapons_t::revolver )
		return g::can_fire_revolver;

	return server_time >= g::local->next_attack ( ) && server_time >= weapon->next_primary_attack ( );
}

int exploits::shifted_tickbase ( ) {
	return shifted_to_tickbase;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	return !shifted_counter;
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
		if ( should_teleport ) {
			if ( recharge_delay_counter ) {
				recharge_delay_counter--;
				return false;
			}

			if ( shifted_counter ) {
				ucmd->m_tickcount += static_cast<int>( cs::time2ticks ( 1.0f ) * 3.125f );
				shifted_counter--;
				has_shifted = false;
				return true;
			}

			return false;
		}
		else {
			recharge_delay_counter = 0;

			if ( shifted_counter ) {
				shifted_counter--;
				has_shifted = false;
				return false;
			}

			return false;
		}
	VM_TIGER_BLACK_END
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 );
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;
	}
}

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	VM_TIGER_BLACK_START
		should_teleport = teleport;

	auto net_chan = cs::i::client_state->net_channel ( );

	if ( !net_chan )
		return;

	last_shifted_amount_ticks = num;

	static auto& enabled = options::vars [ _ ( "ragebot.autopeek" ) ].val.b;
	static auto& autopeek_key = options::vars [ _ ( "ragebot.autopeek_key" ) ].val.i;
	static auto& autopeek_key_mode = options::vars [ _ ( "ragebot.autopeek_key_mode" ) ].val.i;

	const auto autopeek_active = enabled && utils::keybind_active ( autopeek_key, autopeek_key_mode );

	const auto backup_forward_move = ucmd->m_fmove;
	const auto backup_side_move = ucmd->m_smove;
	const auto backup_buttons = ucmd->m_buttons;

	g::send_packet = true;

	for ( auto i = 0; i < num; i++ ) {
		auto next_verified_cmd = cs::i::input->get_verified_cmd ( ucmd->m_cmdnum + 1 );
		auto next_cmd = cs::i::input->get_cmd ( ucmd->m_cmdnum + 1 );

		*next_cmd = *ucmd;

		//if ( !i )
		//	next_cmd->m_tickcount--;
		//else
			next_cmd->m_tickcount += teleport ? 1 : static_cast< int >( cs::time2ticks ( 1.0f ) * 3.125f );

		next_cmd->m_cmdnum++;
		next_cmd->m_hasbeenpredicted = false;

		cs::i::client_state->choked ( )++;

		net_chan->m_choked_packets++;
		net_chan->m_out_sequence_nr++;

		in_exploit = true;
		hooks::create_move ( nullptr, nullptr, 0.0f, next_cmd );
		in_exploit = false;

		///* automatically slow walk on doubletap to increase accuracy */ {
		//	const auto max_speed = ( g::local->scoped ( ) ? g::local->weapon ( )->data ( )->m_max_speed_alt : g::local->weapon ( )->data ( )->m_max_speed ) * 0.33f;
		//	const auto move_norm = vec3_t ( ucmd->m_smove, ucmd->m_fmove, ucmd->m_umove ).normalized();
		//
		//	ucmd->m_fmove = std::clamp< float > ( move_norm.x * max_speed, -g::cvars::cl_forwardspeed->get_float ( ), g::cvars::cl_forwardspeed->get_float ( ) );
		//	ucmd->m_smove = std::clamp< float > ( move_norm.y * max_speed, -g::cvars::cl_sidespeed->get_float ( ), g::cvars::cl_sidespeed->get_float ( ) );
		//
		//	ucmd->m_buttons &= ~buttons_t::walk;
		//}

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		/* set from cmd */
		ucmd = next_cmd;

		shifted_to_command = next_cmd->m_cmdnum;
		shifted_to_tickbase = g::local->tick_base ( );
	}

	g::send_packet = true;
	cs::i::pred->m_previous_start_frame = -1;

	*reinterpret_cast< bool* > ( reinterpret_cast< uintptr_t >( cs::i::pred ) + 0x24 ) = true;
	*reinterpret_cast< int* > ( reinterpret_cast< uintptr_t >( cs::i::pred ) + 0x1C ) = 0;
	VM_TIGER_BLACK_END
}

void exploits::run ( ucmd_t* ucmd ) {
	VM_TIGER_BLACK_START
		if ( !shifted_counter && queued_shift_amount ) {
			pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

			next_shot_time = ( ( g::local && g::local->weapon ( ) && g::local->weapon ( )->data ( ) ) ? ( g::local->weapon ( )->next_primary_attack ( ) + g::local->weapon ( )->data ( )->m_fire_rate ) : 0.0f );

			shifted_counter = queued_shift_amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 ) + 1;
			queued_shift_amount = 0;
			has_shifted = true;
		}

	VM_TIGER_BLACK_END
}