#include "exploits.hpp"
#include "ragebot.hpp"
#include "movement.hpp"

#include "../menu/options.hpp"

#include "../hooks/create_move.hpp"
#include "prediction.hpp"

#include "../sdk/netvar.hpp"

#include "antiaim.hpp"

#undef min
#undef max

float next_shot_time = 0.0f;
int queued_shift_amount = 0;
int shifted_counter = 0;
int recharge_delay_counter = 0;
int shifted_to_command = 0;
int shifted_to_tickbase = 0;
int last_shifted_amount_ticks = 0;
bool should_teleport = false;

bool exploits::can_shoot ( ) {
	VMP_BEGINMUTATION ( );
	if ( !g::local || !g::local->weapon ( ) || !g::local->weapon ( )->ammo ( ) )
		return false;

	const auto weapon = g::local->weapon ( );
	const auto server_time = cs::ticks2time ( g::local->tick_base ( ) );

	if ( weapon->item_definition_index ( ) == weapons_t::revolver )
		return g::can_fire_revolver;

	return server_time >= g::local->next_attack ( ) && server_time >= weapon->next_primary_attack ( );
	VMP_END ( );
}

int exploits::shifted_tickbase ( ) {
	return shifted_to_tickbase;
}

int exploits::shifted_command ( ) {
	return shifted_to_command;
}

int exploits::last_shifted_amount ( ) {
	return last_shifted_amount_ticks;
}

bool exploits::is_recharging ( ) {
	return !recharge_delay_counter && shifted_counter > 0;
}

bool exploits::is_ready ( ) {
	VMP_BEGINMUTATION ( );
	return !shifted_counter && features::ragebot::active_config.dt_enabled && utils::keybind_active ( features::ragebot::active_config.dt_key, features::ragebot::active_config.dt_key_mode );
	VMP_END ( );
}

bool exploits::recharge ( ucmd_t* ucmd ) {
	VMP_BEGINMUTATION ( );
	if ( should_teleport ) {
		if ( recharge_delay_counter ) {
			recharge_delay_counter--;
			return false;
		}

		if ( shifted_counter ) {
			if ( features::ragebot::active_config.dt_smooth_recharge && ucmd->m_cmdnum % 2 != 0 )
				return false;
			
			ucmd->m_tickcount = std::numeric_limits<int>::max ( );
			
			has_shifted = false;
			g::send_packet = true;
			shifted_counter--;

			return true;
		}

		return false;
	}
	else {
		recharge_delay_counter = 0;

		if ( shifted_counter ) {
			shifted_counter--;
			has_shifted = false;
			return false;
		}

		return false;
	}
	VMP_END ( );
}

void exploits::force_recharge ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !recharge_delay_counter ) {
		shifted_counter = amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 );
		recharge_delay_counter = recharge_delay;
	}
}

void exploits::extend_recharge_delay ( int recharge_delay ) {
	if ( should_teleport && recharge_delay_counter > 0 )
		recharge_delay_counter = recharge_delay;
}

void exploits::shift_tickbase ( int amount, int recharge_delay ) {
	if ( !shifted_counter && !queued_shift_amount ) {
		recharge_delay_counter = recharge_delay;
		queued_shift_amount = amount;
	}
}

void exploits::update_incoming_sequences ( int stage ) {
	if ( stage != 2 )
		return;

	if ( !cs::i::client_state || !cs::i::client_state->net_channel( ) )
		return;

	auto nc = cs::i::client_state->net_channel ( );
	
	if ( nc->in_seq_nr > last_incoming_seq_num ) {
		last_incoming_seq_num = nc->in_seq_nr;
		incoming_seqs.push_front ( { nc->in_reliable_state, nc->out_reliable_state, nc->in_seq_nr, cs::i::globals->m_realtime } );
	}

	if ( incoming_seqs.size ( ) > 2048 )
		incoming_seqs.pop_back ( );
}

void exploits::adjust_player_time_base ( player_t* player, int simulation_ticks ) {
	auto net_chan_info = cs::i::engine->get_net_channel_info ( );

	if ( simulation_ticks < 0 || !net_chan_info )
		return;

	static auto cl_predict = cs::i::cvar->find ( _ ( "cl_predict" ) );									/* default to 1 */
	static auto sv_clockcorrection_msecs = cs::i::cvar->find ( _ ( "sv_clockcorrection_msecs" ) );		/* default to 30 */
	static auto sv_playerperfhistorycount = cs::i::cvar->find ( _ ( "sv_playerperfhistorycount" ) );	/* default to 20 */

	/* adjust tickbase below */
	const auto server_tick = g::server_tick + cs::time2ticks ( net_chan_info->get_latency ( 1 ) );

	/* set final simulation time */
	if ( !cl_predict->get_bool( ) || cs::i::globals->m_max_clients == 1 ) {
		player->tick_base ( ) = server_tick - simulation_ticks + 1;
	}
	/* multiplayer */
	else {
		/* clock correction time */
		const auto correction_seconds = std::clamp ( sv_clockcorrection_msecs->get_float( ) / 1000.0f, 0.0f, 1.0f );
		const auto correction_ticks = cs::time2ticks ( correction_seconds );

		/* find ideal tick */
		const auto ideal_final_tick = server_tick + correction_ticks;
		const auto estimated_final_tick = player->tick_base ( ) + simulation_ticks + 1;

		/* correct if client goes ahead of this */
		const auto too_fast_limit = ideal_final_tick + correction_ticks;

		/* correct if client falls behind this */
		const auto too_slow_limit = ideal_final_tick - correction_ticks;

		/* see if we are too fast */
		if ( estimated_final_tick > too_fast_limit || estimated_final_tick < too_slow_limit ) {
			const auto corrected_tick = ideal_final_tick - simulation_ticks;

			player->tick_base ( ) = corrected_tick;
		}
	}
}

namespace lby {
	extern bool in_update;
}

void fix_slide ( ucmd_t* ucmd );

/* CREDITS @CBRS */
void exploits::pack_commands ( ucmd_t* ucmd, int num, bool teleport ) {
	VMP_BEGINMUTATION ( );
	should_teleport = teleport;

	auto net_chan = cs::i::client_state->net_channel ( );
	auto net_chan_info = cs::i::engine->get_net_channel_info ( );

	if ( !net_chan || !net_chan_info )
		return;

	last_shifted_amount_ticks = num;
	shifted_to_tickbase = g::local->tick_base ( );

	static auto& enabled = options::vars [ _ ( "ragebot.autopeek" ) ].val.b;
	static auto& autopeek_key = options::vars [ _ ( "ragebot.autopeek_key" ) ].val.i;
	static auto& autopeek_key_mode = options::vars [ _ ( "ragebot.autopeek_key_mode" ) ].val.i;

	vec3_t backup_angles;
	cs::i::engine->get_viewangles ( backup_angles );

	const auto backup_cmd = *ucmd;

	g::send_cmds = 0;
	g::choked_cmds = 0;

	for ( auto i = 0; i < num; i++ ) {
		const auto next_cmd_num = ucmd->m_cmdnum + 1;
		const auto next_tickcount = ucmd->m_tickcount + ( teleport ? 1 : cs::time2ticks ( 3.125f ) );

		auto next_verified_cmd = cs::i::input->get_verified_cmd ( next_cmd_num );
		auto next_cmd = cs::i::input->get_cmd ( next_cmd_num );

		*next_cmd = backup_cmd;

		next_cmd->m_angs = next_cmd->m_aimdir = backup_angles;

		next_cmd->m_cmdnum = next_cmd_num;
		next_cmd->m_tickcount = next_tickcount;

		next_cmd->m_buttons |= buttons_t::bullrush;
		next_cmd->m_buttons &= ~( buttons_t::attack | buttons_t::attack2 );

		next_cmd->m_hasbeenpredicted = true;

		/* far teleport */
		//if ( abs( next_cmd->m_fmove ) > 3.0f || abs ( next_cmd->m_smove ) > 3.0f ) {
		//	vec3_t move_norm = vec3_t ( next_cmd->m_smove, next_cmd->m_fmove, 0.0f ).normalized ( );
		//
		//	next_cmd->m_smove = std::clamp ( move_norm.x * g::cvars::cl_forwardspeed->get_float ( ), -g::cvars::cl_sidespeed->get_float ( ), g::cvars::cl_sidespeed->get_float ( ) );
		//	next_cmd->m_fmove = std::clamp ( move_norm.y * g::cvars::cl_forwardspeed->get_float ( ), -g::cvars::cl_forwardspeed->get_float ( ), g::cvars::cl_forwardspeed->get_float ( ) );
		//}

		//features::movement::run ( next_cmd, backup_angles );
		fix_slide ( next_cmd );

		//const auto backup_unpred_vel = features::prediction::vel;
		//features::prediction::vel = g::local->vel ( );
		//features::ragebot::slow ( next_cmd );
		//features::prediction::vel = backup_unpred_vel;

		//cs::rotate_movement ( next_cmd, backup_angles );

		cs::clamp ( next_cmd->m_angs );

		tickshift [ ( cs::i::client_state->last_outgoing_cmd ( ) + 1 ) % tickshift.size ( ) ] = {
			cs::i::client_state->last_outgoing_cmd ( ) + 1,
			i + 1
		};

		if ( features::prediction::vel_modifier < 1.0f )
			features::prediction::vel_modifier = std::clamp ( features::prediction::vel_modifier + cs::ticks2time ( 1 ) * 0.4f, 0.0f, 1.0f );

		/* runcommand */
		cs::i::move_helper->set_host ( g::local );
		vfunc<void ( __thiscall* )( c_prediction*, player_t*, ucmd_t*, c_move_helper* )> ( cs::i::pred, 19 )( cs::i::pred, g::local, next_cmd, cs::i::move_helper );
		cs::i::move_helper->set_host ( nullptr );

		//next_cmd->m_hasbeenpredicted = false;

		next_verified_cmd->m_cmd = *next_cmd;
		next_verified_cmd->m_crc = next_cmd->get_checksum ( );

		cs::i::client_state->choked ( )++;

		net_chan->choked_packets = cs::i::client_state->choked ( );
		net_chan->out_seq_nr++;

		g::send_cmds = 0;
		g::choked_cmds++;

		/* recreate what holdaim var does */ {
			if ( g::cvars::sv_maxusrcmdprocessticks_holdaim->get_bool ( ) ) {
				if ( !!( next_cmd->m_buttons & buttons_t::attack ) ) {
					g::angles = next_cmd->m_angs;
					g::hold_aim = true;
				}
			}
			else {
				g::hold_aim = false;
			}

			if ( !g::hold_aim )
				g::angles = next_cmd->m_angs;

			if ( g::send_packet )
				g::hold_aim = false;
		}

		lby::in_update = false;

		if ( g::local && g::local->alive ( ) )
			anims::update_anims ( g::local, lby::in_update ? g::sent_cmd.m_angs : g::angles );
		else
			anims::manage_fake ( );

		features::antiaim::simulate_lby ( );

		/* set from cmd */
		ucmd = next_cmd;
	}

	shifted_to_command = ucmd->m_cmdnum;

	features::prediction::force_repredict ( );
	g::send_packet = true;
	VMP_END ( );
}

void exploits::run ( ucmd_t* ucmd ) {
	VMP_BEGINMUTATION ( );
	if ( !shifted_counter && queued_shift_amount ) {
		pack_commands ( ucmd, queued_shift_amount, features::ragebot::active_config.dt_teleport );

		next_shot_time = ( ( g::local && g::local->weapon ( ) && g::local->weapon ( )->data ( ) ) ? ( g::local->weapon ( )->next_primary_attack ( ) + g::local->weapon ( )->data ( )->m_fire_rate ) : 0.0f );

		shifted_counter = queued_shift_amount + ( ( cs::time2ticks ( cs::i::globals->m_frametime ) > cs::time2ticks ( cs::i::globals->m_ipt ) ) ? cs::time2ticks ( cs::i::globals->m_frametime ) : 0 ) + 1;
		queued_shift_amount = 0;
		has_shifted = true;
	}
	VMP_END ( );
}